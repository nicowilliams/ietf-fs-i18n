<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Internationalization Considerations for Filesystems and Filesystem Protocols</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Filesystem Internationalization">
<link href="#rfc.section.1.2.1" rel="Chapter" title="1.2.1 Canonical Equivalence (Normalization)">
<link href="#rfc.section.1.2.2" rel="Chapter" title="1.2.2 Case Foldings for Case-Insensitivity">
<link href="#rfc.section.1.2.3" rel="Chapter" title="1.2.3 Caching Clients">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Running Code Architecture Notes">
<link href="#rfc.section.2" rel="Chapter" title="2 Filesystem I18N Guidelines">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Filesystem I18N Guidelines: Non-Unicode File names">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Filesystem I18N Guidelines: Case-Insensitivity">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 I18N Versioning">
<link href="#rfc.section.3" rel="Chapter" title="3 Filesystem Protocol I18N Guidelines">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 I18N and Caching in Filesystem Protocol Clients">
<link href="#rfc.section.4" rel="Chapter" title="4 Internationalization Considerations">
<link href="#rfc.section.5" rel="Chapter" title="5 IANA Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="7 References">
<link href="#rfc.references.1" rel="Chapter" title="7.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="7.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Williams, N., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-williams-filesystem-18n-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-06" />
  <meta name="dct.abstract" content="This document describes requirements for internationalization (I18N) of filesystems specifically in the context of Internet protocols, the architecture for filesystems in most currently popular general purpose operating systems, and their implications for filesystem I18N.  From the I18N requirements for filesystems and the architecture of running code we derive requirements and recommendations for implementors of operating systems and/or filesystems, as well as for Internet remote filesystem protocols.  " />
  <meta name="description" content="This document describes requirements for internationalization (I18N) of filesystems specifically in the context of Internet protocols, the architecture for filesystems in most currently popular general purpose operating systems, and their implications for filesystem I18N.  From the I18N requirements for filesystems and the architecture of running code we derive requirements and recommendations for implementors of operating systems and/or filesystems, as well as for Internet remote filesystem protocols.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">N. Williams, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cryptonector, LLC</td>
</tr>
<tr>
<td class="left">Intended status: Best Current Practice</td>
<td class="right">July 6, 2020</td>
</tr>
<tr>
<td class="left">Expires: January 7, 2021</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Internationalization Considerations for Filesystems and Filesystem Protocols<br />
  <span class="filename">draft-williams-filesystem-18n-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes requirements for internationalization (I18N) of filesystems specifically in the context of Internet protocols, the architecture for filesystems in most currently popular general purpose operating systems, and their implications for filesystem I18N.  From the I18N requirements for filesystems and the architecture of running code we derive requirements and recommendations for implementors of operating systems and/or filesystems, as well as for Internet remote filesystem protocols.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 7, 2021.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Filesystem Internationalization</a>
</li>
<ul><li>1.2.1.   <a href="#rfc.section.1.2.1">Canonical Equivalence (Normalization)</a>
</li>
<li>1.2.2.   <a href="#rfc.section.1.2.2">Case Foldings for Case-Insensitivity</a>
</li>
<li>1.2.3.   <a href="#rfc.section.1.2.3">Caching Clients</a>
</li>
</ul><li>1.3.   <a href="#rfc.section.1.3">Running Code Architecture Notes</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Filesystem I18N Guidelines</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Filesystem I18N Guidelines: Non-Unicode File names</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Filesystem I18N Guidelines: Case-Insensitivity</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">I18N Versioning</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Filesystem Protocol I18N Guidelines</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">I18N and Caching in Filesystem Protocol Clients</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Internationalization Considerations</a>
</li>
<li>5.   <a href="#rfc.section.5">IANA Considerations</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.references">References</a>
</li>
<ul><li>7.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>7.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">[TBD: Add references galore.  How to reference Unicode?  How to reference US-ASCII?  How best to reference HFS+?  How best to reference ZFS?  May have to find useful references for POSIX and WIN32.  Various blog entries may be of interest -- can they be referenced?] </p>
<p id="rfc.section.1.p.2">We, the Internet community, have long concluded that we must internationalize all our protocols.  This is generally not an easy task, as often we are constrained by the realities of what can be achieved while maintaining backwards compatibility.  </p>
<p id="rfc.section.1.p.3">In this document we focus on filesystem internationalization (I18N), specifically only for file names and file paths.  Here we address the two main issues that arise in filesystem I18N: </p>

<ul>
<li>Unicode equivalence</li>
<li>Case foldings for case-insensitivity</li>
</ul>

<p> </p>
<p id="rfc.section.1.p.4">These two issues are different flavors of the same generic issue: that there can be more than one way to write text with the same rendering and/or semantics.  </p>
<p id="rfc.section.1.p.5">Only I18N issues relating to file names and paths are addressed here.  In particular, I18N issues related to representations of user identities and groups, for use in access control lists (ACLs) or other authorization systems, are out of scope for this document.  Also out of scope here are I18N issues related to Uniform Resource Identifiers (URIs) <a href="#RFC3986" class="xref">[RFC3986]</a> or Internationalized Resource Identifiers (IRIs) <a href="#RFC3987" class="xref">[RFC3987]</a>.  </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#rfc2119_terms" id="rfc2119_terms">Requirements Language</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.  </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#intro_fs_i18n" id="intro_fs_i18n">Filesystem Internationalization</a>
</h1>
<p id="rfc.section.1.2.p.1">We must address two issues: </p>

<ul>
<li>Unicode equivalence</li>
<li>Case foldings for case-insensitivity</li>
</ul>

<p> </p>
<p id="rfc.section.1.2.p.2">Unicode can represent certain character strings in multiple visually- and semantically-equivalent ways.  For example, there are two ways to express LATIN SMALL LETTER A WITH ACUTE (&#225;): </p>

<ul>
<li>U+00E1</li>
<li>U+0061 U+0301</li>
</ul>

<p> </p>
<p id="rfc.section.1.2.p.3">For some glyphs there is a single way to write them.  For others there are two.  And for yet others there can be many more than two.  </p>
<p id="rfc.section.1.2.p.4">To deal with the equivalence problem, Unicode defines Normal Forms (NFs), of which there are two basic ones: Normal Form Composed (NFC), and Normal Form Decomposed (NFD).  There are also NFs that use "compatibility" Foldings, NFKC and NFKD.  Unicode-aware applications can normalize text to avoid ambiguities, or they can use form-insensitive string comparisons, or both.  </p>
<p id="rfc.section.1.2.p.5">Some filesystems support case-insensitivity, which is trivial to define and implement for US-ASCII, but non-trivial for Unicode, requiring not only larger case-folding tables, but also localized case-folding tables as case-folding rules might differ from locale to locale.  </p>
<h1 id="rfc.section.1.2.1">
<a href="#rfc.section.1.2.1">1.2.1.</a> <a href="#intro_norm" id="intro_norm">Canonical Equivalence (Normalization)</a>
</h1>
<p id="rfc.section.1.2.1.p.1">For case-sensitive filesystems, only Unicode equivalence issues arise as to file names and file paths.  These can be addressed in one of two ways: </p>

<ul>
<li>normalize file names when created and when looked up,</li>
<li>perform form-insensitive string comparisons on lookup.</li>
</ul>

<p> </p>
<p id="rfc.section.1.2.1.p.2">The first option yields normalized file names on-disk and on the wire (e.g., when listing directories).  We shall term this "normalize-on-CREATE", or sometimes "normalize-on-CREATE-and-LOOKUP", or even just "NoCL".  </p>
<p id="rfc.section.1.2.1.p.3">The second option preserves form as originally produced by the user or on their behalf by their system's text input modes, but otherwise is form-insensitive.  That is, this option permits either encoding of, e.g., LATIN SMALL LETTER A WITH ACUTE on-disk and on the wire, but permits only one form of any string, whether normal or not.  We shall term this option "form-insensitive", or sometimes "form-insensitive and form-preserving", or just "FIP".  </p>
<p id="rfc.section.1.2.1.p.4">Unicode compatibility equivalence allows equivalence between different representations of the same abstract character that may nonetheless have different visual appearance of behavior.  There are two canonical forms that support compatibility equivalence: NFKC and NFKD.  Using NoCL with NFKC or NFKD may be surprising to users in a visual way.  While form-insensitivity with NFKC or NFKD may surprise users who might consider two file names distinct even when Unicode considers them equivalent under compatibility equivalence.  The latter seems less likely and less surprising, though that is an entirely subjective judgement.  </p>
<p id="rfc.section.1.2.1.p.5">We do not recommend either of NoCL or FIP over the other.  </p>
<h1 id="rfc.section.1.2.2">
<a href="#rfc.section.1.2.2">1.2.2.</a> <a href="#intro_case" id="intro_case">Case Foldings for Case-Insensitivity</a>
</h1>
<p id="rfc.section.1.2.2.p.1">Case-insensitivity implies folding characters of one case to another for comparison purposes, typically to lower-case.  These case foldings are defined by Unicode.  Generally, case-insensitive filesystems preserve original case just form-insensitive filesystems preserve original form.  </p>
<p id="rfc.section.1.2.2.p.2">It is possible that some case foldings may have to vary by locale.  A commonly used example of character where case foldings that varies by locale is LATIN SMALL LETTER DOTLESS I (U+0131).  </p>
<p id="rfc.section.1.2.2.p.3">In some cases it may be possible to construct case-folding tailorings that are locale-neutral.  For example, all of the following conuld be considered equivalent: </p>

<ul>
<li>LATIN CAPITAL LETTER I (U+0049)</li>
<li>LATIN SMALL LETTER I (U+0069)</li>
<li>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</li>
<li>LATIN SMALL LETTER DOTLESS I (U+0131)</li>
</ul>

<p> which might satisfy a mix of users including those familiar with Turkish and those not, using the same filesystem.  </p>
<h1 id="rfc.section.1.2.3">
<a href="#rfc.section.1.2.3">1.2.3.</a> Caching Clients</h1>
<p id="rfc.section.1.2.3.p.1">Remote filesystem protocols often involve caching on clients, which caching may require knowledge of filesystem I18N settings in order to permit local operations to be performed using cached directory listings that work the same way as on the server.  We do not specify any case foldings here.  Instead we will either create a registry of case folding tailorings, or use the Common Locale Data Repository (CLDR), then require that filesystems and servers be able to identify what case foldings are in effect for case-insensitive filesystems.  </p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#arch_notes" id="arch_notes">Running Code Architecture Notes</a>
</h1>
<p id="rfc.section.1.3.p.1">Surprisingly, almost all if not all general purpose operating systems in common use today have a "virtual filesystem switch" (VFS) <a href="#McKusick86" class="xref">[McKusick86]</a> <a href="https://en.wikipedia.org/wiki/Virtual_file_system">[wikipedia]</a> interface that permits the use of multiple different filesystem types on one system, all accessed through the same filesystems application programming interfaces (APIs).  The VFS is essentially a pluggable layer that includes functionality for routing calls from user processes to the appropriate filesystems.  The VFS has even been generalized and extended to support isolation, thus we have the Filesystem in Userspace (FUSE), which is akin to a remote filesystem protocol, but for use over local inter-process communications (IPC) facilities.  </p>
<p id="rfc.section.1.3.p.2">The VFS architecture was developed in the 1980s, before Unicode adoption.  It is not surprising then that in general -if not simply always today- the code path from the interface between a user application and the operating system all the way to the filesystem implements no I18N functionality whatsoever, and does the absolute minimum of character data interpretation: </p>

<ul>
<li>use of US-ASCII NUL (for "C string" termination),</li>
<li>use of US-ASCII '/' and/or '\' (for file path component delimiting).</li>
</ul>

<p> </p>
<p id="rfc.section.1.3.p.3">For example, the 4.4BSD operating system and derivatives have a VFS <a href="#BSD4.4" class="xref">[BSD4.4]</a>, as do Solaris and derivatives <a href="#SolarisInternals" class="xref">[SolarisInternals]</a>, Windows <span>&lt;</span><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/">https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/</a><span>&gt;</span>, OS X, and Linux.  A VFS of a sort, including FUSE, may well be the only reasonable way to support more than one kind of filesystem while retaining compatibility with previously-existing filesystem APIs.  This explains why so many modern operating systems have a VFS.  </p>
<p id="rfc.section.1.3.p.4">Thus in most if not all general purpose operating systems today, the code path from the boundary between the application and the operating system, and the boundary between the VFS and the filesystem, is "just-use-8" or "just-use-16" (as in UTF-16 <a href="#UNICODE" class="xref">[UNICODE]</a>), with no attempt at normalization or case folding done anywhere in between.  </p>
<p id="rfc.section.1.3.p.5">There are filesystem servers that access raw storage directly and implement the filesystem and the remote filesystem protocol server in one monolythic stack without a VFS in the way, but it is very common to have remote filesystem protocol servers implemented on top of the VFS or on top of the system calls.  Even monolythic servers tend to support a notion of multiple filesystems in a server or volume, and may have different I18N settings for each filesystem.  Thus it's common to leave I18N handling to code layers close to the filesystem even in monolythic server implementations.  </p>
<p id="rfc.section.1.3.p.6">In practice all of foregoing has led to I18N functionality residing strictly in the filesystem.  Two filesystems have defined the best current practices in this regard: </p>

<ul>
<li>HFS+, which does normalize-on-CREATE (and LOOKUP), normalizing to a form that is very close to NFD and is case-sensitive; </li>
<li>ZFS, which implements form-insensitive, form-preserving behavior and optionally implements case-insensitive, case-preserving behavior on a per-filesystem basis.  </li>
</ul>

<p> </p>
<p id="rfc.section.1.3.p.7">Altogether, these circumstances make it very difficult to reliably and always locate I18N functionality above the VFS, or to not use a VFS at all: there are too many places to alter, and all must agree exactly on I18N choices.  Moreover, implementing case-insensitive but case-preserving behavior above the VFS requires fully reading each directory, and so does implementing form-insensitive and form-preserving behavior at the VFS layer itself.  The only behaviors that can be reliably implemented at or above the VFS are normalize- and case-fold-on-CREATE (and LOOKUP).  </p>
<p id="rfc.section.1.3.p.8">Consider the set of already-running code that must all be modified in order to reliably implement I18N above the filesystem on general purpose operating systems: </p>

<ul>
<li>filesystem protocol servers, including but not limited to: <ul>
<li>Network File System (NFSv4) <a href="#RFC7530" class="xref">[RFC7530]</a>;</li>
<li>Hypertext Transfer Protocol (HTTP) servers serving resources hosted on filesystems<a href="#RFC7230" class="xref">[RFC7230]</a>; </li>
<li>SSH File Transfer Protocol (SFTP) <a href="#I-D.ietf-secsh-filexfer" class="xref">[I-D.ietf-secsh-filexfer]</a>; </li>
<li>various remote filesystem protocols that are not Internet Protocols (i.e., not standards-track Internet RFCs); </li>
</ul>
<p> </p>
</li>
<li>POSIX system call layers or user process system call stub libraries;</li>
<li>WIN32 system call layers or user process system call stub libraries.</li>
</ul>

<p> </p>
<p id="rfc.section.1.3.p.9">Regarding system calls and system call stubs in user process system libraries, the continued use of statically-linked executables means that these cannot reliably be modified.  Indeed, on some systems the Application Binary Interface (ABI) between user-space applications and the operating system kernel is well-defined and long-term stable.  The system call handlers cannot reliably inspect the calling process to determine any attributes of its locale.  Adding new system calls is possible, but existing running code wouldn't use them.  For similar reasons, the VFS layer is generally (always) completely unaware of any attributes of the locale of applications calling it, whether via system calls or any other path.  </p>
<p id="rfc.section.1.3.p.10">Unix-like operating systems are generally (always) "just-use-8", assuming only that file names and paths are C strings (i.e., terminated by zero-valued bytes) and sufficiently compatible with US-ASCII that the file path component separator character, US-ASCII '/', is meaningful.  As a result, it is possible to find I18N-unaware filesystems with one or more non-Unicode, non-ASCII codesets in use for file names!  We leave non-ASCII and non-Unicode file names out of scope here.  </p>
<p id="rfc.section.1.3.p.11">For these reasons it is simply not practical to implement I18N at any layer above the VFS.  </p>
<p id="rfc.section.1.3.p.12">Even in the VFS, form- and case-insensitive and -preserving behaviors would be difficult to implement as performantly as in the filesystem.  The VFS would have to list a directory completely before being able to apply those behaviors.  It is reasonable to expect caching clients of remote filesystems to cache directory listings (especially for offline operation), but it isn't reasonable to expect the same of the VFS.  Compare to the filesystem itself, which can maintain a fast index (e.g., hash table or b-tree) where the keys are normalized and possibly case-folded file names and thus may not need to read directories in order to perform fast lookups that are form- and even case-insensitive.  </p>
<p id="rfc.section.1.3.p.13">The only way to implement I18N behaviors in the VFS layer rather than at the filesystem is to abandon form- and case-preserving behaviors.  For case-insensitivity this would require using sentence-case, or all lower-case, perhaps, and all such choices would surely be surprising to users.  At any rate, that approach would also render much running code "non-compliant" with any Internet filesystem protocol I18N specification.  </p>
<p id="rfc.section.1.3.p.14">Therefore, generally speaking, only the filesystem can reliably, interoperably, and performantly implement I18N behaviors in general purpose operating systems.  </p>
<p id="rfc.section.1.3.p.15">Note that variations in I18N behaviors can happen even on the same server with multiple filesystems of the same type.  This can happen because of </p>

<ul class="empty">
<li>different Unicode versions being used at the times of creation of various filesystems, and</li>
<li>different locale settings on various filesystems.</li>
</ul>

<p> </p>
<p id="rfc.section.1.3.p.16">Locale variations are only relevant to case-folding for case-insensitivity.  Running code mostly uses default case-folding rules, but there is no reason to assume that locale-specific case-folding rules won't be supported by running code in the future.  </p>
<p id="rfc.section.1.3.p.17">It may not be possible or easy for a filesystem to adopt new Unicode versions, or adopt backwards-incompatible case foldings, after content has been created in it that would be ambiguous under new rules.  This implies that where a client for a remote filesystem must know what I18N functionality to implement for use with cached directory listings, the client must know specifically what profile of I18N functionality each cached filesystem implements.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#guidelines_fs" id="guidelines_fs">Filesystem I18N Guidelines</a>
</h1>
<p id="rfc.section.2.p.1">We begin be recognizing and accepting that much running code implements I18N functionality at the filesystem.  Given this, we catalogue the range of acceptable behaviors.  Filesystems adhering to this specification MUST implement only acceptable I18N behaviors as specified here.  Acceptable variations may be registered in a to-be-determined (IANA?) registry of filesystem I18N behaviors.  </p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#guidelines_fs_equiv" id="guidelines_fs_equiv">Filesystem I18N Guidelines: Non-Unicode File names</a>
</h1>
<p></p>

<ul>
<li>Filesystems SHOULD reject attempts to create new non-Unicode file names.  </li>
<li>Filesystems either MUST normalize on CREATE (and LOOKUP), or MUST be form-insensitive and form-preserving.  </li>
<li>Filesystems MUST specify a Unicode version for their equivalence behaviors.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#guidelines_fs_case" id="guidelines_fs_case">Filesystem I18N Guidelines: Case-Insensitivity</a>
</h1>
<p></p>

<ul>
<li>Filesystems MAY support case-insensitivity, in which case they SHOULD be case-preserving.  Filesystems that are case-insensitive but not case-preserving either MUST specify a case form, such as title case or sentence case.  </li>
<li>Case foldings for case-insensitive filesystems MUST be identified.  The Unicode default case foldings SHOULD be the default case algorithms for the identified Unicode version without additional tailorings.  Filesystems that use case algorithms tailored to specific locales SHOULD use case foldings registered in a to-be-determined (IANA?) registry.  </li>
<li>Case-insensitive filesystems MUST specify a Unicode version for their case-insensitive behavior.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#guidelines_fs_i18n_versioning" id="guidelines_fs_i18n_versioning">I18N Versioning</a>
</h1>
<p id="rfc.section.2.3.p.1">Each filesystem MUST identify a Unicode version for their I18N behaviors.  Filesystem implementations SHOULD adopt new Unicode versions as they are produced, though it is understood that it may be difficult to migrate non-empty filesystems to new Unicode versions.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#guidelines_proto" id="guidelines_proto">Filesystem Protocol I18N Guidelines</a>
</h1>
<p id="rfc.section.3.p.1">Remote filesystem protocols that allow clients to perform lookups against cached directory listings MUST allow clients to discover all relevant I18N behaviors of the filesystem whence any given directory listing: </p>

<ul>
<li>whether the filesystem normalizes on CREATE (and LOOKUP), and if so, to what NF in what Unicode version;</li>
<li>whether the filesystem is form-insensitive and form-preserving, and if so, in what Unicode version;</li>
<li>whether the filesystem is case-insensitive and case-preserving, and if so, with what foldings (default or tailured, and if tailored provide an identifier for the set of foldings), and a Unicode version.</li>
</ul>

<p> Foldings are identified via a folding set name as registered in a to-be-determined (IANA?) registry.  </p>
<p id="rfc.section.3.p.2">Because some filesystems might allow for different I18N settings on a per-directory basis, remote filesystem protocols MUST allow those settings to be discoverable on a per-directory basis.  </p>
<p id="rfc.section.3.p.3">Internet filesystem servers MUST reject attempts to create new non-Unicode file names.  (Note that this requirement is weaker ("SHOULD") for the actual filesystems, since those might have to allow non-Unicode content for legacy reasons via interfaces other than Internet filesystem protocols.) </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#guidelines_caching" id="guidelines_caching">I18N and Caching in Filesystem Protocol Clients</a>
</h1>
<p id="rfc.section.3.1.p.1">Caching clients of remote filesystems either MUST NOT perform lookups against cached directory listings, or MUST query the directories' filesystems' I18N profiles and apply the same I18N equivalent form policis and case-insensitivity case foldings.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#cons_i18n" id="cons_i18n">Internationalization Considerations</a>
</h1>
<p id="rfc.section.4.p.1">This document deals in internationalization throughout.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#cons_iana" id="cons_iana">IANA Considerations</a>
</h1>
<p id="rfc.section.5.p.1">[ALTERNATIVELY use locale names and CLDR?  Need to determine the stability of CLDR locales...  Basically, we need stable locale names, and stable case-folding mappings.] </p>
<p id="rfc.section.5.p.2">We hereby request the creation of a new IANA registry with Expert Review registration rules with the following fields: </p>

<ul>
<li>name, an identifier-like name</li>
<li>Unicode version number</li>
<li>listing of case folding tailorings and/or references to external case folding tailoring specifications</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.3">The case foldings registered here will be used by case-insensitive filesystems and filesystem protocols to identify tailored case foldings so that caching clients can implement the same case-insensitive behavior using cached directory listings.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#cons_sec" id="cons_sec">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">Security considerations of Unicode and filesystem protocols apply.  No new security considerations are added or need be noted here.  </p>
<p id="rfc.section.6.p.2">The methods of handling equivalent Unicode strings cause aliasing.  This is not expected to be a security problem.  </p>
<p id="rfc.section.6.p.3">Case-insensitivity causes aliasing.  This is not expected to be a security problem.  </p>
<p id="rfc.section.6.p.4">No effort is made here to handle confusables.  This is not expected to be a serious security problem in the context of file servers.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">7.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">7.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="UNICODE">[UNICODE]</b></td>
<td class="top">
<a>The Unicode Consortium</a>, "<a href="https://www.unicode.org/versions/Unicode12.1.0/">The Unicode Standard, Version 12.1.0</a>", May 2019.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">7.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BSD4.4">[BSD4.4]</b></td>
<td class="top">
<a>McKusik, M.</a>, <a>Bostic, K.</a>, <a>Karels, M.</a> and <a>J. Quarterman</a>, "<a>The Design and Implementation of the 4.4BSD Operating System</a>", DOI 10.5555/231070, 1996.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-secsh-filexfer">[I-D.ietf-secsh-filexfer]</b></td>
<td class="top">
<a>Galbraith, J.</a> and <a>O. Saarenmaa</a>, "<a href="https://tools.ietf.org/html/draft-ietf-secsh-filexfer-13">SSH File Transfer Protocol</a>", Internet-Draft draft-ietf-secsh-filexfer-13, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="McKusick86">[McKusick86]</b></td>
<td class="top">
<a>McKusik, M.</a> and <a>M. Karels</a>, "<a>Towards a Compatible File System Interface</a>", Jun 1986.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3987">[RFC3987]</b></td>
<td class="top">
<a>Duerst, M.</a> and <a>M. Suignard</a>, "<a href="https://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>", RFC 3987, DOI 10.17487/RFC3987, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7530">[RFC7530]</b></td>
<td class="top">
<a>Haynes, T.</a> and <a>D. Noveck</a>, "<a href="https://tools.ietf.org/html/rfc7530">Network File System (NFS) Version 4 Protocol</a>", RFC 7530, DOI 10.17487/RFC7530, March 2015.</td>
</tr>
<tr>
<td class="reference"><b id="SolarisInternals">[SolarisInternals]</b></td>
<td class="top">
<a>McDougal, R.</a> and <a>J. Mauro</a>, "<a>Solaris Internals -- Solaris 10 and OpenSolaris Kernel Architecture</a>", 2007.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nico Williams</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Williams</span>
	  </span>
	</span>
	<span class="org vcardline">Cryptonector, LLC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Austin</span>,  
		<span class="region">TX</span> 
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com">nico@cryptonector.com</a></span>

  </address>
</div>

</body>
</html>
